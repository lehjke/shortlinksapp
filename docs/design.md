# Сервис сокращения ссылок — технический дизайн

## Цели

- Принимать длинные URL из консоли и выдавать каждому пользователю уникальную короткую ссылку.
- Определять пользователя по UUID без процедуры авторизации.
- Поддерживать лимит переходов для каждой ссылки и автоматически блокировать её после его достижения.
- Ограничивать время жизни ссылок системным TTL и удалять просроченные записи.
- Уведомлять пользователя о причинах недоступности ссылки (лимит или окончание срока).
- Предоставлять консольные команды для создания, просмотра, удаления и открытия ссылок в браузере.

## Архитектура

```
+-------------------+       +-----------------------+
| ConsoleRunner     |       | ShortLinkCleaner      |
| - меню и команды  |<----->| плановая очистка      |
+-------------------+       +-----------------------+
          |                          ^
          v                          |
+-------------------+       +-----------------------+
| ShortLinkService  |------>| FileShortLinkRepository|
+-------------------+       +-----------------------+
          ^                          ^
          |                          |
+-------------------+       +-----------------------+
| UserService       |       | DataStore (JSON файл) |
+-------------------+       +-----------------------+
```

### Основные компоненты

- **ConsoleRunner** — сценарии взаимодействия в консоли: регистрация, вход по UUID, управление ссылками.
- **ShortLinkService** — бизнес-логика создания, удаления и открытия ссылок с проверкой TTL и лимитов.
- **UserService** — регистрация пользователей и выборка ссылок конкретного владельца.
- **FileShortLinkRepository** — сохранение `DataStore` в `data/store.json` через Jackson (read/write lock для потокобезопасности).
- **ShortLinkCleaner** — `ScheduledExecutorService`, который периодически удаляет просроченные ссылки и пишет итог в лог.
- **NotificationService** — тонкая прослойка для отображения уведомлений (консольная реализация).

## Модель данных

```java
class UserAccount {
    UUID id;
    Instant createdAt;
}

class ShortLink {
    String code;             // короткий код Base62
    UUID ownerId;
    String originalUrl;
    int maxVisits;
    int visitCount;
    Instant createdAt;
    Instant expiresAt;
}

class DataStore {
    Map<UUID, UserAccount> users;
    Map<String, ShortLink> shortLinks; // ключ — code
}
```

## Основные процессы

1. **Регистрация пользователя**  
   - Генерируем `UUID.randomUUID()` при выборе соответствующего пункта меню.  
   - Сохраняем пользователя и показываем его UUID в консоли.

2. **Создание короткой ссылки**  
   - Валидируем URL через `java.net.URI`.  
   - Запрашиваем положительный `maxVisits`.  
   - Считаем `expiresAt = createdAt + defaultTtl`.  
   - Генерируем Base62‑код нужной длины; при коллизии повторяем попытку.  
   - Сохраняем ссылку и выводим полный короткий URL (`{domain}/{code}`).

3. **Переход по короткой ссылке**  
   - Принимаем код или полный URL, извлекаем код.  
   - Проверяем существование, TTL и оставшиеся переходы.  
   - Инкрементируем счётчик, сохраняем результат и открываем оригинальный адрес через `Desktop.getDesktop().browse`.  
   - В случае блокировки сообщаем причину (лимит или истечение).

4. **Очистка**  
   - С интервалом `app.cleanup-interval-seconds` удаляем все просроченные записи из хранилища.  
   - Перезаписываем файл только при изменениях, чтобы сократить операции ввода‑вывода.

## Конфигурация

Файл `src/main/resources/application.properties`:

```
app.short-link-domain=https://clck.ru/
app.short-code-length=7
app.default-ttl-hours=24
app.cleanup-interval-seconds=60
app.storage-file=data/store.json
app.open-browser=true
```

Параметры можно переопределять через JVM‑флаги `-D`, что упрощает тестирование (например, уменьшение TTL).

## Стратегия тестирования

- Unit‑тесты `ShortLinkService` проверяют:
  - уникальность кодов при одинаковых URL разных пользователей;
  - срабатывание лимита переходов и сообщения об ошибках;
  - реакцию на просроченные ссылки;
  - работу очистки, удаляющей протухшие записи.
- При необходимости можно эмулировать сценарии консоли через сервисный слой (интеграционный подход).

## Возможные расширения

- REST/HTTP‑API на базе Spring Boot с повторным использованием текущих сервисов.
- Перенос данных в СУБД (PostgreSQL) вместо файлового хранилища.
- Дополнительные каналы уведомлений: e‑mail, push, вебхуки.
